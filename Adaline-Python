# -*- coding: utf-8 -*-
"""
Created on Fri Nov 22 15:30:31 2019

@author: Tiago Buffulin
"""

#bibliotecas
#Rede Adaline

import pandas as pd #leitura de arquivo
import numpy as np 
import matplotlib.pyplot as plt #graficos
from numpy.random import seed
from random import uniform
import math
import random
random.randrange (start=-1,stop=1)

class Pydaline:
    
    def __init__(self):
        #inicializa o Pydaline
        self.pesos = []
        self.saidas_desejadas = []
        self.entradas = []
        self.taxadeaprendizagem = 0.7
        self.erro = 0.3
        self.debug = True
        self.epocas = 0
        self.erroGlobal = 1 #inicia o programa sem treinamento
        
    def setDebug(self,debug = True):
        #SE FOR ATIVO, MOSTRA AS MENSAGENS DE TREINAMENTO    
        self.debug = debug
        
    def setEntradas(self,entradas):
    #atualização de pesos
        if entradas.__len__()>=2:
            #criando novos pesos
            self.entradas = entradas
            self.pesos = []
            
            for i in range(0,entradas[0].__len__()):
                self.pesos.append(random.random())
                
    def setSaidasDesejadas(self,saidas):
        #função para ajustar as saidas necessarias para o treinamento do neuronio
        if saidas.__len__()>=2:
            self.saidas_desejadas = saidas
    
    def criterio_parada(self):
        #criterio de parada ******MODIFICAR VALOR*******
        return (self.epocas == COLOCAR VALOR AQUI) #TREINAMENTO MAXIMO EM X EPOCAS
    
    def somatorio(self,numEntrada):
        #somatoria do produto de cada entrada com seu respectivo peso
        somatorio = 0
        for i in range (0,self.entradas[numEntrada.__len__()):
            somatorio += self.pesos[i]*self.entradas[numEntrada][i]
        return somatorio
    
    def ativacao(self,numEntrada):
        #função de ativação
        somatorio = self.somatorio(numEntrada)
        if somatorio>=self.erro:
            return 1
        elif somatorio<-self.erro:  #ELIF É USADO QUANDO EXISTE MAIS DE UMA CONDIÇÃO ALTERNATIVA QUE PRECISA SER VERIFICADA
            return -1
        return 0
    
    def aprender(self):
        #Treinamento por épocas.
        if self.saidas_desejadas.__len__()!=self.entradas.__len__():
            raise RuntimeError ("O numero de entradas e diferente do numero de saida desejada.")
        while self.erroGlobal != 0 and not self.criterio_parada():
            self.epocas += 1
            if self.debug: print "Iniciando epoca: ",self.epocas,". Erro Global:",self.erroGlobal
            self.erroGlobal = 0
            self.treina()
            
    def treina(self):
        #PERCORRA ENTRADA, CALCULA AS SAIDAS E PASSA O ERRO PARA A FUNÇÂO DE AJUSTE
        
        for i in range(0,self.entradas.__len__()): #treinamento do neuronio para cada entrada
            ativacao = self.ativacao(i)
            erro = self.saidas_desejadas[i]-ativacao
            self.erroGlobal += erro.__abs__()
            if self.debug:
                print " Entradas",self.entradas[i]
                print " Saida desejada: ",self.saidas_desejadas[i]
                print " Saida encontrada: ",ativacao
                print " Erro: ",erro
                print " Pesos: ",self.pesos
            self.ajusta_pesos(erro,i)
            
        def ajusta_pesos(self,erro,numEntrada):
            #Realiza o ajuste de pesos (aprendizado) quando houver erro
            
            if erro !=0:
                plen = self.pesos.__len__()
                for j in range(0,plen):
                    self.pesos[j] = self.pesos[j] + self.erro*erro*self.erro*erro*self.entradas[numEntrada][j]
                if self.debug: print " Pesos atualizados:", self.pesos
                
            def obter_resposta_para_entrada(self,entrada):
                if entrada.__len__() != self.entradas[0].__len__():
                    raise RunTimeError("A entrada deve ter o mesmo tamanho das usadas no treinamento")
                self.entradas.append(entrada)
                resultado = self.ativacao(self.entradas.__len__()-1)
                self.entradas.pop()
                return resultado
            
